<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ko"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GameLogic.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tetris</a> &gt; <a href="index.source.html" class="el_package">com.example.game.component</a> &gt; <span class="el_source">GameLogic.java</span></div><h1>GameLogic.java</h1><pre class="source lang-java linenums">package com.example.game.component;

import java.util.Random;

import com.example.game.blocks.Block;
import com.example.game.blocks.IBlock;
import com.example.game.blocks.JBlock;
import com.example.game.blocks.LBlock;
import com.example.game.blocks.OBlock;
import com.example.game.blocks.SBlock;
import com.example.game.blocks.TBlock;
import com.example.game.blocks.ZBlock;

public class GameLogic {

    // 보드 크기
    public static final int HEIGHT = 20; // 20줄
    public static final int WIDTH = 10; // 10칸

    private int[][] board; // 0: 빈칸, 1: 채워진 칸
    private String[][] blockTypes; // 색상 추적용
    private Block currentBlock; // 현재 블록
    private Block nextBlock; // 다음 블록
<span class="fc" id="L24">    private int x = 3; // 현재 블록 X좌표</span>
<span class="fc" id="L25">    private int y = -1; // 현재 블록 Y좌표</span>
    private Random random; // 랜덤 블록 생성용
<span class="fc" id="L27">    private boolean gameOver = false; // 게임 오버 상태</span>

    // 속도 관련 변수들 추가
<span class="fc" id="L30">    private int totalBlocksSpawned = 0;      // 생성된 총 블록 수</span>
<span class="fc" id="L31">    private int totalLinesCleared = 0;       // 삭제된 총 줄 수</span>
<span class="fc" id="L32">    private int currentLevel = 1;            // 현재 레벨</span>
<span class="fc" id="L33">    private int speedLevel = 1;              // 속도 레벨 (별도 관리)</span>
    
    // 속도 증가 기준
    private static final int BLOCKS_PER_SPEED_INCREASE = 10;  // 10개 블록마다 속도 증가
    private static final int LINES_PER_SPEED_INCREASE = 5;    // 5줄마다 속도 증가
    private static final double SPEED_MULTIPLIER = 0.9;      // 속도 증가율 (90% = 10% 빨라짐)
    private static final double MIN_SPEED_MULTIPLIER = 0.1;  // 최대 속도 (원래의 10%)

<span class="fc" id="L41">    public GameLogic() {</span>
<span class="fc" id="L42">        random = new Random();</span>
<span class="fc" id="L43">        initializeGame();</span>
<span class="fc" id="L44">    }</span>

    // 게임 초기화
    private void initializeGame() {
<span class="fc" id="L48">        board = new int[HEIGHT][WIDTH]; // 모두 0으로 초기화</span>
<span class="fc" id="L49">        blockTypes = new String[HEIGHT][WIDTH]; // 모두 null로 초기화</span>
<span class="fc" id="L50">        currentBlock = getRandomBlock(); // 첫 블록 생성</span>
<span class="fc" id="L51">        nextBlock = getRandomBlock(); // 다음 블록 생성</span>
<span class="fc" id="L52">        x=3;</span>
<span class="fc" id="L53">        y=-1;</span>
<span class="fc" id="L54">        gameOver = false;</span>
<span class="fc" id="L55">        placeCurrent(); // 현재 블록 보드에 놓기</span>
        
        // 통계 초기화
<span class="fc" id="L58">        totalBlocksSpawned = 1; // 첫 블록 카운트</span>
<span class="fc" id="L59">        totalLinesCleared = 0;</span>
<span class="fc" id="L60">        currentLevel = 1;</span>
<span class="fc" id="L61">        speedLevel = 1;</span>
<span class="fc" id="L62">    }</span>

    public Block getRandomBlock() {
<span class="fc" id="L65">        int blockType = random.nextInt(7);</span>
<span class="pc bpc" id="L66" title="1 of 8 branches missed.">        switch (blockType) {</span>
            case 0:
<span class="fc" id="L68">                return new IBlock();</span>
            case 1:
<span class="fc" id="L70">                return new JBlock();</span>
            case 2:
<span class="fc" id="L72">                return new LBlock();</span>
            case 3:
<span class="fc" id="L74">                return new ZBlock();</span>
            case 4:
<span class="fc" id="L76">                return new SBlock();</span>
            case 5:
<span class="fc" id="L78">                return new TBlock();</span>
            case 6:
<span class="fc" id="L80">                return new OBlock();</span>
            default:
<span class="nc" id="L82">                return new IBlock();</span>
        }
    }

    // 블록 아래로 이동
    public boolean moveDown() {
        // 현재 블록 지우기
<span class="fc" id="L89">        eraseCurrent();</span>
        // 아래로 이동 가능하면 이동
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (canMove(x, y + 1, currentBlock)) {</span>
<span class="fc" id="L92">            y++;</span>
<span class="fc" id="L93">            placeCurrent(); // 이동 후 다시 놓기</span>
<span class="fc" id="L94">            return true;</span>
        } else { // 이동 불가하면 제자리
<span class="nc" id="L96">            placeCurrent();</span>
            //spawnNewBlock(); // 새 블록 생성
<span class="nc" id="L98">            return false;</span>
        }
    }

    // 블록 좌우 이동
    public void moveLeft() {
<span class="fc" id="L104">        eraseCurrent();</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (canMove(x - 1, y, currentBlock)) {</span>
<span class="fc" id="L106">            x--;</span>
        }
<span class="fc" id="L108">        placeCurrent();</span>
<span class="fc" id="L109">    }</span>

    public void moveRight() {
<span class="fc" id="L112">        eraseCurrent();</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (canMove(x + 1, y, currentBlock)) {</span>
<span class="fc" id="L114">            x++;</span>
        }
<span class="fc" id="L116">        placeCurrent();</span>
<span class="fc" id="L117">    }</span>

    // 블록 회전
    public void rotateBlock() {
<span class="fc" id="L121">        eraseCurrent();</span>
<span class="fc" id="L122">        currentBlock.rotate();</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        if (!canMove(x, y, currentBlock)) {</span>
            // 회전 후 이동 불가하면 원래대로 돌리기
            // 3번 회전하면 원래 상태
<span class="nc bnc" id="L126" title="All 2 branches missed.">            for (int i = 0; i &lt; 3; i++) {</span>
<span class="nc" id="L127">                currentBlock.rotate();</span>
            }
        }
<span class="fc" id="L130">        placeCurrent();</span>
<span class="fc" id="L131">    }</span>

    // 새 블록 생성
    public boolean spawnNextPiece() {
    // 1) 다음 블록을 현재로 승격
<span class="fc" id="L136">    currentBlock = nextBlock;</span>
<span class="fc" id="L137">    nextBlock = getRandomBlock();</span>

    // 2) 스폰 좌표 설정 (현재 x=3, y=0을 기본으로 사용하셨으므로 유지)
<span class="fc" id="L140">    x = 3;</span>
<span class="fc" id="L141">    y = -1;</span>

    // 3) 스폰 가능? (경계/충돌 검사)
<span class="fc bfc" id="L144" title="All 2 branches covered.">    if (!canMove(x, y, currentBlock)) {</span>
        
        // 스폰 불가 → 게임오버 플래그
<span class="fc" id="L147">        gameOver = true;</span>
<span class="fc" id="L148">        return false;</span>
    }
    // 블록 생성 수 증가
<span class="fc" id="L151">        totalBlocksSpawned++;</span>
        
        // 속도 레벨 업데이트
<span class="fc" id="L154">        updateSpeedLevel();</span>
    // 4) 스폰 성공 → 보드에 반영(지우개/그리기 방식 유지)
<span class="fc" id="L156">    placeCurrent();</span>
<span class="fc" id="L157">    return true;</span>
}

    // 블록이 특정 위치로 이동 가능한지 확인
    // newX, newY: 블록의 새 좌표
    // block: 이동할 블록
    public boolean canMove(int newX, int newY, Block block) {
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (block == null) {</span>
<span class="nc" id="L165">            return false;</span>
        }

<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (int i = 0; i &lt; block.width(); i++) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            for (int j = 0; j &lt; block.height(); j++) {</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">                if (block.getShape(i, j) == 1) {</span>
                    // 블록의 현재 좌표에 대한 보드 좌표 계산
<span class="fc" id="L172">                    int boardX = newX + i;</span>
<span class="fc" id="L173">                    int boardY = newY + j;</span>

                    // 좌우 경계 확인
<span class="pc bpc" id="L176" title="2 of 4 branches missed.">                    if (boardX &lt; 0 || boardX &gt;= WIDTH) {</span>
<span class="nc" id="L177">                        return false;</span>
                    }

                    // 하단 경계 확인
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">                    if (boardY &gt;= HEIGHT) {</span>
<span class="nc" id="L182">                        return false;</span>
                    }

                    // 상단 경계는 약간의 여유를 둠 (블록이 화면 위쪽에서 시작할 수 있도록)
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">                    if (boardY &lt; -2) {</span>
<span class="nc" id="L187">                        return false;</span>
                    }

                    // 보드 내부의 충돌 확인 (boardY가 0 이상인 경우에만)
<span class="fc bfc" id="L191" title="All 4 branches covered.">                    if (boardY &gt;= 0 &amp;&amp; board[boardY][boardX] == 1) {</span>
<span class="fc" id="L192">                        return false;</span>
                    }
                }
            }
        }
<span class="fc" id="L197">        return true;</span>
    }

    // 현재 블록 지우기
    private void eraseCurrent() {
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (currentBlock == null) {</span>
<span class="nc" id="L203">            return;</span>
        }

<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (int i = 0; i &lt; currentBlock.width(); i++) {</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            for (int j = 0; j &lt; currentBlock.height(); j++) {</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">                if (currentBlock.getShape(i, j) == 1) {</span>
                    // 현재 블록의 보드 좌표 계산
<span class="fc" id="L210">                    int boardX = x + i;</span>
<span class="fc" id="L211">                    int boardY = y + j;</span>

                    // 보드 경계 내에서만 지우기
<span class="pc bpc" id="L214" title="3 of 8 branches missed.">                    if (boardX &gt;= 0 &amp;&amp; boardX &lt; WIDTH &amp;&amp; boardY &gt;= 0 &amp;&amp; boardY &lt; HEIGHT) {</span>
<span class="fc" id="L215">                        board[boardY][boardX] = 0;</span>
<span class="fc" id="L216">                        blockTypes[boardY][boardX] = null;</span>
                    }
                }
            }
        }
<span class="fc" id="L221">    }</span>

    // 현재 블록 놓기
    private void placeCurrent() {
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if (currentBlock == null) {</span>
<span class="nc" id="L226">            return;</span>
        }

<span class="fc bfc" id="L229" title="All 2 branches covered.">        for (int i = 0; i &lt; currentBlock.width(); i++) {</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">            for (int j = 0; j &lt; currentBlock.height(); j++) {</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">                if (currentBlock.getShape(i, j) == 1) {</span>
                    // 현재 블록의 보드 좌표 계산
<span class="fc" id="L233">                    int boardX = x + i;</span>
<span class="fc" id="L234">                    int boardY = y + j;</span>

                    // 보드 경계 내에서만 놓기
<span class="pc bpc" id="L237" title="3 of 8 branches missed.">                    if (boardX &gt;= 0 &amp;&amp; boardX &lt; WIDTH &amp;&amp; boardY &gt;= 0 &amp;&amp; boardY &lt; HEIGHT) {</span>
<span class="fc" id="L238">                        board[boardY][boardX] = 1;</span>
<span class="fc" id="L239">                        blockTypes[boardY][boardX] = currentBlock.getCssClass();</span>
                    }
                }
            }
        }
<span class="fc" id="L244">    }</span>

    // 줄 삭제
    public int clearLines() {
        // 삭제된 줄 수 반환
<span class="fc" id="L249">        int linesCleared = 0;</span>

        // 아래에서 위로 검사
<span class="fc bfc" id="L252" title="All 2 branches covered.">        for (int row = HEIGHT - 1; row &gt;= 0; row--) {</span>
<span class="fc" id="L253">            boolean fullLine = true;</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">            for (int col = 0; col &lt; WIDTH; col++) {</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">                if (board[row][col] == 0) {</span>
<span class="fc" id="L256">                    fullLine = false;</span>
<span class="fc" id="L257">                    break;</span>
                }
            }

            // 줄이 꽉 찼으면 삭제
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">            if (fullLine) {</span>
                // 위의 줄들을 한 칸씩 내리기
<span class="nc bnc" id="L264" title="All 2 branches missed.">                for (int moveRow = row; moveRow &gt; 0; moveRow--) {</span>
<span class="nc" id="L265">                    System.arraycopy(board[moveRow - 1], 0, board[moveRow], 0, WIDTH);</span>
<span class="nc" id="L266">                    System.arraycopy(blockTypes[moveRow - 1], 0, blockTypes[moveRow], 0, WIDTH);</span>
                }
                // 맨 위 줄 지우기
<span class="nc bnc" id="L269" title="All 2 branches missed.">                for (int col = 0; col &lt; WIDTH; col++) {</span>
<span class="nc" id="L270">                    board[0][col] = 0;</span>
<span class="nc" id="L271">                    blockTypes[0][col] = null;</span>
                }

<span class="nc" id="L274">                linesCleared++;</span>
<span class="nc" id="L275">                row++;</span>
            }
        }

        // 줄 삭제 통계 업데이트
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if (linesCleared &gt; 0) {</span>
<span class="nc" id="L281">            totalLinesCleared += linesCleared;</span>
<span class="nc" id="L282">            updateSpeedLevel();</span>
            
            // 디버깅 출력
<span class="nc" id="L285">            System.out.println(&quot;Lines cleared: &quot; + linesCleared + &quot;, Total lines: &quot; + totalLinesCleared);</span>
<span class="nc" id="L286">            System.out.println(&quot;Blocks spawned: &quot; + totalBlocksSpawned + &quot;, Speed level: &quot; + speedLevel);</span>
        }

<span class="fc" id="L289">        return linesCleared;</span>
    }

    public boolean isBlockAtTop() {
<span class="nc bnc" id="L293" title="All 2 branches missed.">    if (currentBlock == null) {</span>
<span class="nc" id="L294">        return false;</span>
    }
    
<span class="nc" id="L297">    boolean atTop = false;</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">    for (int i = 0; i &lt; currentBlock.width(); i++) {</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        for (int j = 0; j &lt; currentBlock.height(); j++) {</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">            if (currentBlock.getShape(i, j) == 1) {</span>
<span class="nc" id="L301">                int boardY = y + j;</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">                if (boardY == 0) {</span>
<span class="nc" id="L303">                    atTop = true;</span>
        
                }
            }
        }
    }
<span class="nc" id="L309">    return atTop;</span>
}

    // 게임 종료 확인
    // 속도 레벨 업데이트
    private void updateSpeedLevel() {
<span class="fc" id="L315">        int oldSpeedLevel = speedLevel;</span>
        
        // 블록 수에 따른 속도 증가
<span class="fc" id="L318">        int speedFromBlocks = totalBlocksSpawned / BLOCKS_PER_SPEED_INCREASE;</span>
        
        // 줄 삭제 수에 따른 속도 증가
<span class="fc" id="L321">        int speedFromLines = totalLinesCleared / LINES_PER_SPEED_INCREASE;</span>
        
        // 둘 중 높은 값을 사용 (더 빠른 진행)
<span class="fc" id="L324">        speedLevel = Math.max(speedFromBlocks, speedFromLines) + 1;</span>
        
        // 레벨도 업데이트 (UI 표시용)
<span class="fc" id="L327">        currentLevel = speedLevel;</span>
        
        //디버깅용 출력
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (speedLevel != oldSpeedLevel) {</span>
<span class="nc" id="L331">            System.out.println(&quot;Speed level increased to: &quot; + speedLevel + &quot; (was: &quot; + oldSpeedLevel + &quot;)&quot;);</span>
        }
<span class="fc" id="L333">    }</span>

    // 속도 계산 (배수 반환)
    public double getSpeedMultiplier() {
<span class="nc" id="L337">        double multiplier = Math.pow(SPEED_MULTIPLIER, speedLevel - 1);</span>
<span class="nc" id="L338">        return Math.max(multiplier, MIN_SPEED_MULTIPLIER);</span>
    }

    // 드롭 간격 계산 (나노초)
    public long getDropInterval(long baseInterval) {
<span class="nc" id="L343">        return (long)(baseInterval * getSpeedMultiplier());</span>
    }

    public boolean isGameOver() {
<span class="fc" id="L347">    return gameOver;</span>
    }

    // Getters
    public int[][] getBoard() {
<span class="fc" id="L352">        return board;</span>
    }

    public String[][] getBlockTypes() {
<span class="nc" id="L356">        return blockTypes;</span>
    }

    public Block getCurrentBlock() {
<span class="fc" id="L360">        return currentBlock;</span>
    }

    public Block getNextBlock() {
<span class="fc" id="L364">        return nextBlock;</span>
    }

    public int getCurrentX() {
<span class="fc" id="L368">        return x;</span>
    }

    public int getCurrentY() {
<span class="fc" id="L372">        return y;</span>
    }

    // 새로 추가된 Getters
    public int getTotalBlocksSpawned() {
<span class="fc" id="L377">        return totalBlocksSpawned;</span>
    }

    public int getTotalLinesCleared() {
<span class="fc" id="L381">        return totalLinesCleared;</span>
    }

    public int getCurrentLevel() {
<span class="fc" id="L385">        return currentLevel;</span>
    }

    public int getSpeedLevel() {
<span class="fc" id="L389">        return speedLevel;</span>
    }

    public void resetGame() {
<span class="fc" id="L393">        initializeGame();</span>
<span class="fc" id="L394">    }</span>

    // 디버깅용 메서드
    public void printSpeedInfo() {
<span class="nc" id="L398">        System.out.println(&quot;=== Speed Info ===&quot;);</span>
<span class="nc" id="L399">        System.out.println(&quot;Blocks spawned: &quot; + totalBlocksSpawned);</span>
<span class="nc" id="L400">        System.out.println(&quot;Lines cleared: &quot; + totalLinesCleared);</span>
<span class="nc" id="L401">        System.out.println(&quot;Speed level: &quot; + speedLevel);</span>
<span class="nc" id="L402">        System.out.println(&quot;Speed multiplier: &quot; + String.format(&quot;%.2f&quot;, getSpeedMultiplier()));</span>
<span class="nc" id="L403">        System.out.println(&quot;==================&quot;);</span>
<span class="nc" id="L404">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>